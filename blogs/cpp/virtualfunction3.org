* 我眼中的虚函数3(类,继承,接口)
** 先讨论一个小问题,
***  为什么构建子类的时候会调用基类构造函数
#+BEGIN_SRC c++
#include <iostream>
using namespace std;
class A{
public:
  A(){cout<<"A::A()"<<endl;}
  virtual ~A(){cout<<"A::~A()"<<endl;}
};
class B: public A{
public:
  B(){cout<<"B::B()"<<endl;}
  B(int a){cout<<"B::B()"<<endl;}
  virtual ~B(){cout<<"B::~B()"<<endl;}
};
int main(){
  B *pb = new B;
  return 0;
};
#+END_SRC
打印结果:
#+BEGIN_SRC c++
A::A()
B::B()
A::A()
B::B()
#+END_SRC
为什么是这样,其实是编译器再B构造函数中插入了A的构造函数.不管是在默认的构造函数函数在自定义的构造函数中类似这样
#+BEGIN_SRC c++
B::B(){
A::A();
cout<<"B::B()"<<endl;
}
#+END_SRC
不信?可以看看可能汇编代码
#+BEGIN_SRC c++
LC0:
	.ascii "A::A()\0"
...
__ZN1AC2Ev:
	movl	$LC0, 4(%esp)
	movl	$__ZSt4cout, (%esp)
...
LC2:
	.ascii "B::B()\0"
...
__ZN1BC1Ev:
	call	__ZN1AC2Ev
	movl	$LC2, 4(%esp)
	movl	$__ZSt4cout, (%esp)
...
#+END_SRC
大概的猜到函数B::B的汇编call了一个__ZN1AC2Ev而这个label 刚好就是A::A函数的实现.有兴趣可以自己动手试试:g++ -S xx.cpp。同理，析构函数也是这样实现的。这里补充一下虚虚构函数在虚表里面的表现。接上面代码,A有一个虚构函数，B也有一个虚析构函数函数在虚函数表中会不会有存在两个析构函数呢,
#+BEGIN_SRC c++
#include <iostream>
using namespace std;
class A{
public:
  A(){cout<<"A::A()"<<endl;}
  virtual void f1(){cout<<"A::f1"<<endl;}
  virtual void f2(){cout<<"A::f2"<<endl;}
  virtual ~A(){cout<<"A::~A()"<<endl;}
private:
  int ma;
};
class B:public A{
public:
  B(){cout<<"B::B()"<<endl;}
  B(int a){cout<<"B::B()"<<endl;}
  void f2(){cout<<"B::f2"<<endl;}
  virtual ~B(){cout<<"B::~B()"<<endl;}
  int mb;
};

int main(){
  B *pb = new B;
  return 0;
};
#+END_SRC

新添加了两个虚函f1和f2，在子类B中改写了f2,下面我们来看看虚表是什么样的
A虚表：
#+BEGIN_SRC c++
Thread 1 "vf3" hit Breakpoint 1, main () at vf3.cc:22
22        A *pa = new A;
(gdb) n
A::A()
23        A *pb = new B;
(gdb) n
A::A()
B::B()
24        return 0;
(gdb) p *pa
$1 = {_vptr.A = 0x40309c <vtable for A+8>, ma = -2147249046}
(gdb) p /a *(void**)0x40309c@3
$2 = {0x401820 <A::f1()>, 0x401850 <A::f2()>, 0x401918 <A::~A()>}
#+END_SRC
可以看到A的虚函数按照声明顺序在虚表当中排列，再来看看B的虚表
#+BEGIN_SRC c++
(gdb) p *pb
$3 = {_vptr.A = 0x4030b4 <vtable for B+8>, ma = 0}
(gdb) p /a *(void**)0x4030b4@3
$4 = {0x401820 <A::f1()>, 0x401988 <B::f2()>, 0x401a40 <B::~B()>}
#+END_SRC
同样也是按照声明顺序排列，子类重写的函数会替换掉对应的父类函数，比如f2.等等 A的虚函数呢？ 我们去掉B中的虚函数再看看
#+BEGIN_SRC c++
Thread 1 "vf3" hit Breakpoint 1, main () at vf3.cc:18
18        A *pa = new A;
(gdb) l
13        B(int a){cout<<"B::B()"<<endl;}
14        void f2(){cout<<"B::f2"<<endl;}
15        //virtual ~B(){cout<<"B::~B()"<<endl;}
16      };
17      int main(){
18        A *pa = new A;
19        A *pb = new B;
20        return 0;
21      };
(gdb) n
A::A()
19        A *pb = new B;
(gdb) n
A::A()
B::B()
20        return 0;
(gdb) p *pb
$1 = {_vptr.A = 0x4030ac <vtable for B+8>}
(gdb) p /a *(void**)0x4030ac@3
$2 = {0x401820 <A::f1()>, 0x401988 <B::f2()>, 0x401a40 <B::~B()>}
#+END_SRC
我去掉了子类中的虚析构函数，但是再B的虚表中依然看到了B::~B().说明编译器自动生成了这个函数。

** 继承 
这里暂时讲讲继承对虚函数的影响以及虚继承
*** 单继承
    通过上面的例子可以看出单继承的时候子类的虚表指针指向一张虚表，这张虚表包含父类所有的虚函数地址，然后用对应子类重写的虚函数替换掉，是的虚析构函数有点特殊
*** 多重继承
    多重继承最常见的问题就是二义性，和菱形继承什么是二义性，所谓的二义性就是多个基类里面有相同的函数，在子类对象调用的时候，编译器区分不出到底调用的是哪个函数，看下面代码
#+BEGIN_SRC c++
namespace nv{
  class A{
  public:
    void f1(){cout<<"A::f1"<<endl;}
  };

  class B{
  public:
    void f1(){cout<<"B::f2"<<endl;}
  };
  class C: public A,public B{
  };
}
int main(){
  nv::C *pc = new nv::C;
  pc->f1();
  return 0;
};
#+END_SRC
基类A 和 B都有函数f1,C继承了两份f1代码，在函数调用的时候编译器不知道到底使用哪个函数，解决办法可以在调用的时候指定具体的函数比如这样
#+BEGIN_SRC c++
pc->A::f1();
#+END_SRC
还有一个办法是使用using,这样也能解决二义性问题
#+BEGIN_SRC c++
  class C: public A,public B{
  public:
  using A::f1;
  };
#+END_SRC
using的做法相当于是在C中用A::f1遮挡住B::f1,这样在编译器在C中是看不到B::f1的，调用f1的时候顺理成章使用了A::f1,那么如果C要同时使用A 和B的f1 怎么办呢?老老实实用第一种办法吧
上面是普通成员函数在多重继承中的情况，那么虚函数在在多重继承中又会是什么样的情况呢。
#+BEGIN_SRC c++
  class A{
  public:
    virtual void f1(){cout<<"A::f1"<<endl;}

  };

  class B{
  public:
    virtual void f1(){cout<<"B::f2"<<endl;}
  };
  class C: public A,public B{
  };
  int main(){
    C *pc = new C;
    pc->f1();
    pc->B::f1();
    return 0;
  };

#+END_SRC
同样遇了编译器的错误警告，解决办法同普通函数一样.
下面来看看在多重继承的情况下虚表长什么样的呢。
#+BEGIN_SRC c++
class A{
public:
  virtual void af1(){cout<<"A::af1"<<endl;}
  virtual void af2(){cout<<"A::af2"<<endl;}
};

class B{
public:
  virtual void bf1(){cout<<"B::bf2"<<endl;}
  virtual void bf2(){cout<<"B::bf2"<<endl;}
};
class C: public A,public B{
};
int main(){
  v::C *pc = new v::C;
  return 0;
};
//////
(gdb) p *pc
$1 = {<v::A> = {_vptr.A = 0x4030cc <vtable for v::C+8>}, <v::B> = {
    _vptr.B = 0x4030dc <vtable for v::C+24>}, <No data fields>}
(gdb) p /a *(void**)0x4030cc@2
$2 = {0x4017b0 <v::A::af1()>, 0x4017e0 <v::A::af2()>}
(gdb) p /a *(void**)0x4030dc@2
$3 = {0x401820 <v::B::bf1()>, 0x401850 <v::B::bf2()>}
#+END_SRC
在不重载函数的时候子类会有两个虚表指针分别指向父类(_vptr.A,_vptr.B)，尝试重载基类的虚函数。
#+BEGIN_SRC  c++
  class A{
  public:
    virtual void af1(){cout<<"A::af1"<<endl;}
    virtual void af2(){cout<<"A::af2"<<endl;}
  };

  class B{
  public:
    virtual void bf1(){cout<<"B::bf2"<<endl;}
    virtual void bf2(){cout<<"B::bf2"<<endl;}
  };
  class C: public A,public B{
  public:
    void af1(){cout<<"C::af1"<<endl;}
    void bf2(){cout<<"C::bf2"<<endl;}
  };
  int main(){
    C *pc = new C;
    pc->af1();
    pc->bf2();
    return 0;
  };
#+END_SRC
用gdb查看虚函数表
#+BEGIN_SRC c++
38        C *pc = new C;
(gdb) n
39        pc->af1();
(gdb) p *pc
$1 = {<A> = {_vptr.A = 0x4030cc <vtable for C+8>}, <B> = {
    _vptr.B = 0x4030e0 <vtable for C+28>}, <No data fields>}
(gdb) p /a *(void**)0x4030cc@2
$2 = {0x4018b0 <C::af1()>, 0x401800 <A::af2()>}
(gdb) p /a *(void**)0x4030e0@2
$4 = {0x401948 <_ZThn4_N1C3bf1Ev>, 0x401870 <B::bf2()>}
#+END_SRC

我用的是cygwin+windows10,gdb version 8.1.1 ,gcc version 7.4.0,可以看到对于继承下来A的虚表在C中函数af1的位置由C重写的函数替换，基类B的bf1函数由_ZThn4_N1C3bf1Ev(0x401948)这个函数替代，看名字是C的bf1，是不是很奇怪为什么显示和A的不一样。我们再来看看_vptr.A其他的内容

#+BEGIN_SRC c++
(gdb) p /a *(void**)0x4030cc@3
$21 = {0x4018b0 <C::af1()>, 0x401800 <A::af2()>, 0x4018e0 <C::bf1()>}
#+END_SRC
在基类A虚表中找到了重写过后的C::bf1,那么在基类B的虚表中第一个函数又是什么呢，如果是同一个函数那么为什么地址确不相同，如果是两个函数 那么为什么重写会多出来一个函数。尝试分别调用一下这两个地址
#+BEGIN_SRC c++
  Thread 1 "vf3" hit Breakpoint 1, main () at vf3.cc:38
  38        C *pc = new C;
  (gdb) n
  39        pc->af1();
  (gdb) p *pc
  $1 = {<A> = {_vptr.A = 0x4030d4 <vtable for C+8>}, <B> = {
      _vptr.B = 0x4030e8 <vtable for C+28>}, <No data fields>}
  (gdb) p /a *(void**)0x4030e8@2
  $3 = {0x401948 <_ZThn4_N1C3bf1Ev>, 0x401870 <B::bf2()>}
  (gdb) p /a *(void**)0x4030d4@3
  $4 = {0x4018b0 <C::af1()>, 0x401800 <A::af2()>, 0x4018e0 <C::bf1()>}
  (gdb) p *(void *())(0x4018e0)()
  [New Thread 20752.0x4064]
  [New Thread 20752.0xaa0]
  C::bf1
  (gdb) p *(void *())(0x401948)()
  C::bf1
  (gdb)
#+END_SRC
从打印可以看出这两货是同一个，怎么可能呢，没办法只能拿出终极手段，看汇编
#+BEGIN_SRC c++
(gdb) p *pc
$5 = {<A> = {_vptr.A = 0x4030d4 <vtable for C+8>}, <B> = {
    _vptr.B = 0x4030e8 <vtable for C+28>}, <No data fields>}
(gdb) p *(void**)0x4030d4@3
$6 = {0x4018b0 <C::af1()>, 0x401800 <A::af2()>, 0x4018e0 <C::bf1()>}
(gdb) disas pc->bf1
Dump of assembler code for function C::bf1():
   0x004018e0 <+0>:     push   ebp
#+END_SRC
汇编显示指针调用重写过的虚函数后，调用的是A虚表里面的函数，说明重写的虚函数被放进了第一个基类的虚表.第二个虚表里面的函数呢？忘了它把。我暂时没找到合理的解释为什么g++会将第二个虚表会变成这样。


