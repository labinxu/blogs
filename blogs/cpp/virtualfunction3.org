* 我眼中的虚函数3(类,继承,接口)
** 先讨论一个小问题,
***  为什么构建子类的时候会调用基类构造函数
#+BEGIN_SRC c++
#include <iostream>
using namespace std;
class A{
public:
  A(){cout<<"A::A()"<<endl;}
  virtual ~A(){cout<<"A::~A()"<<endl;}
};
class B: public A{
public:
  B(){cout<<"B::B()"<<endl;}
  B(int a){cout<<"B::B()"<<endl;}
  virtual ~B(){cout<<"B::~B()"<<endl;}
};
int main(){
  B *pb = new B;
  return 0;
};
#+END_SRC
打印结果:
#+BEGIN_SRC c++
A::A()
B::B()
A::A()
B::B()
#+END_SRC
为什么是这样,其实是编译器再B构造函数中插入了A的构造函数.不管是在默认的构造函数函数在自定义的构造函数中类似这样
#+BEGIN_SRC c++
B::B(){
A::A();
cout<<"B::B()"<<endl;
}
#+END_SRC
不信?可以看看可能汇编代码
#+BEGIN_SRC c++
LC0:
	.ascii "A::A()\0"
...
__ZN1AC2Ev:
	movl	$LC0, 4(%esp)
	movl	$__ZSt4cout, (%esp)
...
LC2:
	.ascii "B::B()\0"
...
__ZN1BC1Ev:
	call	__ZN1AC2Ev
	movl	$LC2, 4(%esp)
	movl	$__ZSt4cout, (%esp)
...
#+END_SRC
大概的猜到函数B::B的汇编call了一个__ZN1AC2Ev而这个label 刚好就是A::A函数的实现.有兴趣可以自己动手试试:g++ -S xx.cpp。同理，析构函数也是这样实现的。这里补充一下虚虚构函数在虚表里面的表现。接上面代码,A有一个虚构函数，B也有一个虚析构函数函数在虚函数表中会不会有存在两个析构函数呢,
#+BEGIN_SRC c++
#include <iostream>
using namespace std;
class A{
public:
  A(){cout<<"A::A()"<<endl;}
  virtual void f1(){cout<<"A::f1"<<endl;}
  virtual void f2(){cout<<"A::f2"<<endl;}
  virtual ~A(){cout<<"A::~A()"<<endl;}
private:
  int ma;
};
class B:public A{
public:
  B(){cout<<"B::B()"<<endl;}
  B(int a){cout<<"B::B()"<<endl;}
  void f2(){cout<<"B::f2"<<endl;}
  virtual ~B(){cout<<"B::~B()"<<endl;}
  int mb;
};

int main(){
  B *pb = new B;
  return 0;
};
#+END_SRC

新添加了两个虚函f1和f2，在子类B中改写了f2,下面我们来看看虚表是什么样的
A虚表：
#+BEGIN_SRC c++
Thread 1 "vf3" hit Breakpoint 1, main () at vf3.cc:22
22        A *pa = new A;
(gdb) n
A::A()
23        A *pb = new B;
(gdb) n
A::A()
B::B()
24        return 0;
(gdb) p *pa
$1 = {_vptr.A = 0x40309c <vtable for A+8>, ma = -2147249046}
(gdb) p /a *(void**)0x40309c@3
$2 = {0x401820 <A::f1()>, 0x401850 <A::f2()>, 0x401918 <A::~A()>}
#+END_SRC
可以看到A的虚函数按照声明顺序在虚表当中排列，再来看看B的虚表
#+BEGIN_SRC c++
(gdb) p *pb
$3 = {_vptr.A = 0x4030b4 <vtable for B+8>, ma = 0}
(gdb) p /a *(void**)0x4030b4@3
$4 = {0x401820 <A::f1()>, 0x401988 <B::f2()>, 0x401a40 <B::~B()>}
#+END_SRC
同样也是按照声明顺序排列，子类重写的函数会替换掉对应的父类函数，比如f2.等等 A的虚函数呢？ 我们去掉B中的虚函数再看看
#+BEGIN_SRC c++
Thread 1 "vf3" hit Breakpoint 1, main () at vf3.cc:18
18        A *pa = new A;
(gdb) l
13        B(int a){cout<<"B::B()"<<endl;}
14        void f2(){cout<<"B::f2"<<endl;}
15        //virtual ~B(){cout<<"B::~B()"<<endl;}
16      };
17      int main(){
18        A *pa = new A;
19        A *pb = new B;
20        return 0;
21      };
(gdb) n
A::A()
19        A *pb = new B;
(gdb) n
A::A()
B::B()
20        return 0;
(gdb) p *pb
$1 = {_vptr.A = 0x4030ac <vtable for B+8>}
(gdb) p /a *(void**)0x4030ac@3
$2 = {0x401820 <A::f1()>, 0x401988 <B::f2()>, 0x401a40 <B::~B()>}
#+END_SRC
我去掉了子类中的虚析构函数，但是再B的虚表中依然看到了B::~B().说明编译器自动生成了这个函数。

** 继承 
这里暂时讲讲继承对虚函数的影响以及虚继承
*** 单继承
    通过上面的例子可以看出单继承的时候子类的虚表指针指向一张虚表，这张虚表包含父类所有的虚函数地址，然后用对应子类重写的虚函数替换掉，是的虚析构函数有点特殊
*** 多重继承
    多重继承最常见的问题就是二义性，和菱形继承什么是二义性，所谓的二义性就是多个基类里面有相同的函数，在子类对象调用的时候，编译器区分不出到底调用的是哪个函数，看下面代码
#+BEGIN_SRC c++
namespace nv{
  class A{
  public:
    void f1(){cout<<"A::f1"<<endl;}
  };

  class B{
  public:
    void f1(){cout<<"B::f2"<<endl;}
  };
  class C: public A,public B{
  };
}
int main(){
  nv::C *pc = new nv::C;
  pc->f1();
  return 0;
};
#+END_SRC
基类A 和 B都有函数f1,C继承了两份f1代码，在函数调用的时候编译器不知道到底使用哪个函数，解决办法可以在调用的时候指定具体的函数比如这样
#+BEGIN_SRC c++
pc->A::f1();
#+END_SRC
还有一个办法是使用using,这样也能解决二义性问题
#+BEGIN_SRC c++
  class C: public A,public B{
  public:
  using A::f1;
  };
#+END_SRC
using的做法相当于是在C中用A::f1遮挡住B::f1,这样在编译器在C中是看不到B::f1的，调用f1的时候顺理成章使用了A::f1,那么如果C要同时使用A 和B的f1 怎么办呢?老老实实用第一种办法吧
上面是普通成员函数在多重继承中的情况，那么虚函数在在多重继承中又会是什么样的情况呢。
#+BEGIN_SRC c++
  class A{
  public:
    virtual void f1(){cout<<"A::f1"<<endl;}

  };

  class B{
  public:
    virtual void f1(){cout<<"B::f2"<<endl;}
  };
  class C: public A,public B{
  };
  int main(){
    C *pc = new C;
    pc->f1();
    pc->B::f1();
    return 0;
  };

#+END_SRC
同样我们遭遇了编译器的错误警告，解决办法同普通函数一样.
下面来看看在多重继承的情况下虚表长什么样的呢。
#+BEGIN_SRC c++
class A{
public:
  virtual void af1(){cout<<"A::af1"<<endl;}
  virtual void af2(){cout<<"A::af2"<<endl;}
};

class B{
public:
  virtual void bf1(){cout<<"B::bf2"<<endl;}
  virtual void bf2(){cout<<"B::bf2"<<endl;}
};
class C: public A,public B{
};
int main(){
  v::C *pc = new v::C;
  return 0;
};
//////
(gdb) p *pc
$1 = {<v::A> = {_vptr.A = 0x4030cc <vtable for v::C+8>}, <v::B> = {
    _vptr.B = 0x4030dc <vtable for v::C+24>}, <No data fields>}
(gdb) p /a *(void**)0x4030cc@2
$2 = {0x4017b0 <v::A::af1()>, 0x4017e0 <v::A::af2()>}
(gdb) p /a *(void**)0x4030dc@2
$3 = {0x401820 <v::B::bf1()>, 0x401850 <v::B::bf2()>}
#+END_SRC
在不重载函数的时候子类会有两个虚表指针分别指向父类(_vptr.A,_vptr.B)
