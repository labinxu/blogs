* 1 参数

#prac1.sh arg1 args2
# 参数的个数
numberofargmuments(){
    echo "The number of args: " "$#"
    #>> 2
    # $0 当前执行脚本的相对路径
    echo "shell script path:" $0
    #$1 $2 分别代表第一 第二个参数
    # 获取当前脚本的路径1
    currentdir=$(cd $(dirname $0)|pwd)
    echo "current dir is(cd dirname pwd)": "$currentdir"
    # 说明 $(dirname $0) 获取当前脚本的目录的相对路径,cd 进去 执行pwd获得全路径
    # 获取当前脚本的路径2
    currentdir=$(dirname $(readlink -f $0))
    echo "current dir is(dirname readlink -f)": "$currentdir"
}
# uncomment
# numberofargmuments $*
** 1.2 参数的处理 1
# $* 除$0以外的所有参数, 是一个完整的字符串
# $@ 除$0以外的所有参数, 是一个数组
# 两者区别可以用下面的代码看出来
##./prac1.sh arg1 arg2
arguments_deal1(){
    echo print '$*'
    for arg in "$*";do
        echo "$arg"
    done
    # arg1 arg2 输出为一行
    echo print '$@'
    for arg in "$@";do
        echo "$arg"
    done
    # 输出为2行
    # arg1
    # arg2
}
# uncomment it
#arguments_deal1 $@
#arguments_deal1  $*

** 1.3 参数处理 2
argment_deal2(){
    # ./prac1.sh -m option or ./prac1.sh option -m
    # 如何取出option
    #可以先判断$1 or $2 然后再取出option
    if [ "$1" = "-m" ];then
        echo '$0' is -m and value is: $2
    fi
    #or
    if [ "$2" = "-m" ];then
        echo '$2' is -m and value is: $1
    fi
}

# uncommtents
# argment_deal2 $@

** 参数处理3 
# shift 会将参数往左移动一位，也就相当于删除第一个参数
# eg:./prac1.sh -f v1 v2 v3  or ./prac1.sh v1 v2 v3 -f
arguments_deal3(){
    values=""
    while [ -n "$1" ];do
        if [ "$1" = "-f" ];then
            shift 
            continue
        else
            values="$values $1"
        fi
        shift
    done

    echo argments values:"$values"
}
#arguments_deal3 $@


* 字符串
** 字符串截取
   var="/user/home/user1"
   echo ${var#*home/} # 去掉*home/ 留下 user1
** split & count
    count=0
    vars=$(echo $var | tr '/' ' ') # split
    for v in ${vars};do
        count=`expr $count + 1` # count
        echo $v
    done
    # tr commands can referce here https://www.cnblogs.com/bingguoguo/articles/9188703.html
** join
    joinedstr=""
    for v in ${vars};do
        if [ "$joinedstr" = "" ]; then

            joinedstr=$v
        else
            joinedstr="$joinedstr#$v"
        fi
    done

* 目录
** 列出绝对路径
  files=$(ls | sed "s:^:`pwd`/: ")
  for f in $files;do echo $file 
  done
  
* 函数
** 函数的定义函数反回和调用
bash可以有关键字function 但是dash没有，一律不使用function 关键字
函数可以返回一些字符串或者数字
funcreturnstr(){
	echo "returnstring"
}
if [ $(funcreturnstr) = "returnstring" ] ;then
   echo "return ok"
fi
# 带参数
funcreturnstr(){
if [ "$1" = "1" ];then
	echo "return1"
elif [ "$1" = "2" ];then
	echo "return2"
else
	echo "returnstring"
fi
}
if [ $(funcreturnstr 1) = "return1" ];then
   echo "return1 ok"
fi
# 注意参数$1 在比较的时候一定要加双引号，不要问为什么，谁不加谁知道。
* here string
在使用while read 的时候会遇到在while里面的变量无法更改 比如
total=0
echo "a,b,c" | tr ',' '\n'|while read x;do
	$((total=total+1))
	echo in while total:$total
done
echo out total:$total

#out total打印始终为0 原因就是 代码是通过管道传送给while read 进程，total变量被传到了
#子进程中，而父进程是得不到在子进程中的更改的，要获得这个更改需要使用here documents
# eg:
echo "===here documents====="
total=0
while read x;do
	total=`expr $total + 1`
	echo in while total:$total
done<<EOF
`echo "a,b,c" | tr ',' '\n'`
EOF

* 读取文件
文件每行存放的方式为key value 中间是空格，如果要取出key为某一个值的时候可以这样 
while read line;do
 
# 第一种方法
key=`echo $line | cut -d ' ' -f1`
if [ "$key" = "key2" ] ;then
	echo first method: "$key"
fi

#第二中方法
read x y <<EOF
$line
EOF
if [ "$x" = "key3" ];then
	echo second method: $x , $y
fi

done < tmpfile


* 需要注意的地方
** 判断文件夹和文件
if [ -f file ];#
if [ -d folder ];#
#如果只是判断路径是否存在可以用 -e
if [ -e path ] ;
** 使用参数比较的时候一定要用双引号
shell将参数按字符串解析，如果不用引号括起来，字符串中间有空格的时候，会出现两个字符串这样就出问题了。
** 文件操作的时候需要注意路径，绝对路径或相对路径，要统一


# https://www.jianshu.com/p/762d4cccee7e
# http://blog.chinaunix.net/uid-25266990-id-3268759.html
# https://www.cnblogs.com/Malphite/p/7742406.html
# https://www.cnblogs.com/zwgblog/p/6031256.html
# https://www.cnblogs.com/xuxm2007/p/7554543.html
# https://www.cnblogs.com/wangtao1993/p/6136894.html
